{"componentChunkName":"component---src-templates-post-tsx","path":"/optimizing-react-application-with-mobx-f101785379d9/","result":{"data":{"logo":null,"markdownRemark":{"html":"<p>From 1.5 sec to 50–100ms (per update)</p>\n<p>There is my short story about how I improved performance of the web-app by 10x with just a simple trick.</p>\n<p>I was building web-based application for a client. It was captions (subtitles) review tool for videos. So you have a video, you have list of subtitles and you want to edit them.</p>\n<p><img src=\"/49b3a5a0c9a1df5c0be374301b1dacca/react-mobx-perf-1.png\" alt=\"Captions list\"></p>\n<p>One day I have loaded large projects into the app. The project had several hundreds of captions. The app was not fast, but it was working good enough. Until I click “delete” button of the first caption. I noticed that this operation was VERY slow. It took about <strong>1.5</strong> sec for deleting. This glitch was very noticeable. Why was it slow? After some investigation, I found that React has to rerender ALL captions on delete. You may ask why, if it is just deleting? The thing is — each caption should show its index (see in top left). So when you delete the first caption, indexes of all other captions need to be updated.</p>\n<p>As a proof I deleted the last element, it was very fast. It may still look strange why updating of indexes is slow. Even if react didn’t need to touch a lot of elements (pfuuu, just several hundreds), it needs to do a LOT of work under the hood. It needs to call render for each element, it needs to create a new tree of virtual DOM and it needs to calculate changes and it needs to apply them. This operation tooks long time because one caption component has many elements inside.</p>\n<p>I started to think to use <a href=\"https://github.com/bvaughn/react-virtualized\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">react-virtualized</a> for hiding invisible captions. This should 100% solve the issue. But, the app has some features about scrolling list in several conditions. To calculate correct scrolling position I needed all elements to be in the DOM (otherwise calculation is too complex). As I have some legacy code, this change may take too long time to implement and test and it may break the app in some cases.</p>\n<p>So I continued to think about a faster solution. In that project, I was using <a href=\"https://mobx.js.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">mobx</a> for state management. The cool thing about it is observable values and ability to create React components that OBSERVE changes. So I thought: I need to update item element but how to update index directly without calling render of the whole caption?</p>\n<p>This is how part for render function was looking before changes:</p>\n<p><img src=\"/72d0a94e6ffb99f55abc6e6ad948d819/react-mobx-perf-2.png\" alt=\"Segment code\"></p>\n<p><a href=\"https://github.com/mobxjs/mobx-react\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">mobx-react</a> automatically track usage of properties in render function. “index” property changed — component updated.</p>\n<p>But here is quick and simple fix. Let us create special component for displaying JUST index:</p>\n<p><img src=\"/78c8f3549a622f8be0252a2320735014/react-mobx-perf-3.png\" alt=\"Index code\"></p>\n<p>And then we will use this component inside render of whole item:</p>\n<p><img src=\"/1578ecd1ce5675f15436d5ee476d9597/react-mobx-perf-4.png\" alt=\"Index code\"></p>\n<p>What did it change? In this case I am not using “index” property directly inside item render. So when I updated the index this component is not updated (it doesn’t observe that changes). BUT child component will be updated (directly and very fast), because it listens to changes of “index” property.</p>\n<p>Notice that this approach <strong>will not work</strong>, if you will use index directly here, like <code class=\"language-text\">&lt;IndexTest index={segment.index}/&gt;</code></p>\n<p>Performance improved A LOT with this simple refactoring.</p>\n<p>Every time you want to fix performance of a web-app remember to be smart and measure the performance. In my case one item element has many properties (index, text, start time, end time and many other). And I didn’t move rendering of all of these properties into separate components. It just make no sense.</p>\n<blockquote>\n<p>Question: what is the best way to apply something similar if you are using pure setState or redux architecture? I didn’t have anything beautiful in mind, do you?</p>\n</blockquote>\n<p>Looking of help with react performance? <a href=\"/consulting/web-perf.html\">Send me a message</a>.</p>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"From 1.5 sec to 50–100ms (per update)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"There is my short story about how I improved performance of the web-app by 10x with just a simple trick."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I was building web-based application for a client. It was captions (subtitles) review tool for videos. So you have a video, you have list of subtitles and you want to edit them."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/49b3a5a0c9a1df5c0be374301b1dacca/react-mobx-perf-1.png","alt":"Captions list"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"One day I have loaded large projects into the app. The project had several hundreds of captions. The app was not fast, but it was working good enough. Until I click “delete” button of the first caption. I noticed that this operation was VERY slow. It took about "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"1.5"}]},{"type":"text","value":" sec for deleting. This glitch was very noticeable. Why was it slow? After some investigation, I found that React has to rerender ALL captions on delete. You may ask why, if it is just deleting? The thing is — each caption should show its index (see in top left). So when you delete the first caption, indexes of all other captions need to be updated."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"As a proof I deleted the last element, it was very fast. It may still look strange why updating of indexes is slow. Even if react didn’t need to touch a lot of elements (pfuuu, just several hundreds), it needs to do a LOT of work under the hood. It needs to call render for each element, it needs to create a new tree of virtual DOM and it needs to calculate changes and it needs to apply them. This operation tooks long time because one caption component has many elements inside."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I started to think to use "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/bvaughn/react-virtualized","target":"_blank","rel":["nofollow","noopener","noreferrer"]},"children":[{"type":"text","value":"react-virtualized"}]},{"type":"text","value":" for hiding invisible captions. This should 100% solve the issue. But, the app has some features about scrolling list in several conditions. To calculate correct scrolling position I needed all elements to be in the DOM (otherwise calculation is too complex). As I have some legacy code, this change may take too long time to implement and test and it may break the app in some cases."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So I continued to think about a faster solution. In that project, I was using "},{"type":"element","tagName":"a","properties":{"href":"https://mobx.js.org/","target":"_blank","rel":["nofollow","noopener","noreferrer"]},"children":[{"type":"text","value":"mobx"}]},{"type":"text","value":" for state management. The cool thing about it is observable values and ability to create React components that OBSERVE changes. So I thought: I need to update item element but how to update index directly without calling render of the whole caption?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This is how part for render function was looking before changes:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/72d0a94e6ffb99f55abc6e6ad948d819/react-mobx-perf-2.png","alt":"Segment code"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://github.com/mobxjs/mobx-react","target":"_blank","rel":["nofollow","noopener","noreferrer"]},"children":[{"type":"text","value":"mobx-react"}]},{"type":"text","value":" automatically track usage of properties in render function. “index” property changed — component updated."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"But here is quick and simple fix. Let us create special component for displaying JUST index:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/78c8f3549a622f8be0252a2320735014/react-mobx-perf-3.png","alt":"Index code"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"And then we will use this component inside render of whole item:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/1578ecd1ce5675f15436d5ee476d9597/react-mobx-perf-4.png","alt":"Index code"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"What did it change? In this case I am not using “index” property directly inside item render. So when I updated the index this component is not updated (it doesn’t observe that changes). BUT child component will be updated (directly and very fast), because it listens to changes of “index” property."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Notice that this approach "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"will not work"}]},{"type":"text","value":", if you will use index directly here, like "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"<IndexTest index={segment.index}/>"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Performance improved A LOT with this simple refactoring."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Every time you want to fix performance of a web-app remember to be smart and measure the performance. In my case one item element has many properties (index, text, start time, end time and many other). And I didn’t move rendering of all of these properties into separate components. It just make no sense."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Question: what is the best way to apply something similar if you are using pure setState or redux architecture? I didn’t have anything beautiful in mind, do you?"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Looking of help with react performance? "},{"type":"element","tagName":"a","properties":{"href":"/consulting/web-perf.html"},"children":[{"type":"text","value":"Send me a message"}]},{"type":"text","value":"."}]}],"data":{"quirksMode":false}},"excerpt":"From 1.5 sec to 50–100ms (per update) There is my short story about how I improved performance of the web-app by 10x with just a simple…","timeToRead":3,"frontmatter":{"title":"Optimizing React application with mobx","userDate":"20 October 2017","date":"2017-10-20","tags":["react"],"image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAQCBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAGDXMVSmH//xAAZEAACAwEAAAAAAAAAAAAAAAAAAwECEiD/2gAIAQEAAQUCqpckpWZrx//EABURAQEAAAAAAAAAAAAAAAAAABAh/9oACAEDAQE/AYf/xAAWEQADAAAAAAAAAAAAAAAAAAAAARH/2gAIAQIBAT8BrKz/xAAbEAACAQUAAAAAAAAAAAAAAAAAAZEDICEyM//aAAgBAQAGPwLNRSdFJsrP/8QAGhABAAEFAAAAAAAAAAAAAAAAAQARIDFxof/aAAgBAQABPyHEl0gCvNE2y//aAAwDAQACAAMAAAAQAy//xAAXEQADAQAAAAAAAAAAAAAAAAAAARFR/9oACAEDAQE/EJgiP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QK//EABsQAQACAgMAAAAAAAAAAAAAAAEAESAhYXGx/9oACAEBAAE/ENIodFHst6jixjAFO8P/2Q==","aspectRatio":1.5,"src":"/static/7e1b8af93cf8f46a0defa94922cfaf1d/47498/react-mobx-perf-cover.jpg","srcSet":"/static/7e1b8af93cf8f46a0defa94922cfaf1d/2f037/react-mobx-perf-cover.jpg 930w,\n/static/7e1b8af93cf8f46a0defa94922cfaf1d/47498/react-mobx-perf-cover.jpg 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"author":{"id":"Anton","bio":"Anton Lavrenov","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAUDAv/EABcBAAMBAAAAAAAAAAAAAAAAAAABAgP/2gAMAwEAAhADEAAAAYW+dlVCdHKyDkDWP//EAB0QAAEDBQEAAAAAAAAAAAAAAAEAAgMEISQxMkH/2gAIAQEAAQUCRhkDU3qxpjvxpxSv/8QAFREBAQAAAAAAAAAAAAAAAAAAASD/2gAIAQMBAT8BCP/EABgRAAIDAAAAAAAAAAAAAAAAAAABECFB/9oACAECAQE/AY0as//EABsQAAEFAQEAAAAAAAAAAAAAABEAAQIQIRIx/9oACAEBAAY/Al08cpijM+Wx01//xAAbEAEBAAIDAQAAAAAAAAAAAAABEQAxECFBYf/aAAgBAQABPyGaDeIXA94nal7mFDOQl+5CkIXXB3zEbgLn/9oADAMBAAIAAwAAABCDF0H/xAAZEQEAAgMAAAAAAAAAAAAAAAABABEQMXH/2gAIAQMBAT8QswaeQWp//8QAGREBAAIDAAAAAAAAAAAAAAAAAQARECFx/9oACAECAQE/EFrAWOwran//xAAcEAEAAwACAwAAAAAAAAAAAAABABEhMVFxwfD/2gAIAQEAAT8QEgLTQSjAdqomsFxgnsiI8obCcPLUdmpJ0Op7QABZ0ufEU0y9on//2Q==","width":400,"height":400,"src":"/static/d0b7acc08864a814c399f5bd88540f65/25252/anton.jpg","srcSet":"/static/d0b7acc08864a814c399f5bd88540f65/25252/anton.jpg 1x,\n/static/d0b7acc08864a814c399f5bd88540f65/c3638/anton.jpg 1.5x"}}]}}}},"relatedPosts":{"totalCount":6,"edges":[{"node":{"id":"1740e8c3-67a5-5554-b527-133b1e0cea92","timeToRead":8,"excerpt":"Do you want to make a seat booking platform on your website? This post will describe steps to design a seat reservation system for music…","frontmatter":{"title":"Case study: Seats Reservation Widget with Javascript"},"fields":{"slug":"/case-study-seat-reservation-widget/"}}},{"node":{"id":"387b6b7a-88d8-5ec1-b245-84306cb6273d","timeToRead":6,"excerpt":"Looking of help with react performance? Send me a message. Tips to optimise rendering of a set of elements in React There is a guide to…","frontmatter":{"title":"Tips to optimise rendering of a set of elements in React"},"fields":{"slug":"/how-to-optimise-rendering-of-a-set-of-elements-in-react-ad01f5b161ae/"}}},{"node":{"id":"2c43558a-3544-5f29-9da8-4758b6647173","timeToRead":5,"excerpt":"Need to label images to train a neural network? This post will describe how to design a system for labeling objects on an image by a human…","frontmatter":{"title":"Case study: Image Labeling with JavaScript"},"fields":{"slug":"/case-study-image-labeling-for-machine-learning/"}}}]}},"pageContext":{"slug":"/optimizing-react-application-with-mobx-f101785379d9/","prev":{"excerpt":"How to run async loops in sequence or in parallel? Before doing asynchronous magic with loops I want to remind you how we write classical…","timeToRead":3,"frontmatter":{"title":"JavaScript loops - how to handle async/await","tags":["javascript"],"date":"2017-10-31","image":{"childImageSharp":{"fluid":{"aspectRatio":1.7782026768642447,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMBAgT/xAAVAQEBAAAAAAAAAAAAAAAAAAACA//aAAwDAQACEAMQAAAB2OS2rkuFf//EABgQAQADAQAAAAAAAAAAAAAAAAEAAhAR/9oACAEBAAEFAqhOGEM//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQIBAT8BZ//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABgQAQEAAwAAAAAAAAAAAAAAAAEAEDFR/9oACAEBAAE/IWbjtBkL/9oADAMBAAIAAwAAABADH//EABYRAQEBAAAAAAAAAAAAAAAAAAABEf/aAAgBAwEBPxCRj//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAECAQE/ECv/xAAaEAEBAQEAAwAAAAAAAAAAAAABACERMUFR/9oACAEBAAE/EFUaPrfMM73h9LCEIZf/2Q==","sizes":"(max-width: 2560px) 100vw, 2560px","src":"/static/c83567175db202b5488ea83c36a10dfd/4a461/async-loops-cover2.jpg","srcSet":"/static/c83567175db202b5488ea83c36a10dfd/2f037/async-loops-cover2.jpg 930w,\n/static/c83567175db202b5488ea83c36a10dfd/23f4e/async-loops-cover2.jpg 1860w,\n/static/c83567175db202b5488ea83c36a10dfd/4a461/async-loops-cover2.jpg 2560w"}}},"author":{"id":"Anton","bio":"Anton Lavrenov","avatar":{"children":[{"fixed":{"src":"/static/d0b7acc08864a814c399f5bd88540f65/25252/anton.jpg"}}]}}},"fields":{"layout":"post","slug":"/javascript-loops-how-to-handle-async-await-6252dd3c795/"}},"next":{"excerpt":"Progressive loading for modern web applications via code splitting Are your users tired of waiting when your app is loading and they close…","timeToRead":6,"frontmatter":{"title":"Progressive loading for modern web applications via code splitting","tags":["javascript"],"date":"2016-07-20","image":{"childImageSharp":{"fluid":{"aspectRatio":1.5,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAEDBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB4DpSsoyP/8QAGRAAAgMBAAAAAAAAAAAAAAAAABEBAhAx/9oACAEBAAEFAhZQRPf/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAYEAEAAwEAAAAAAAAAAAAAAAABABAhEf/aAAgBAQABPyEO21kQUf/aAAwDAQACAAMAAAAQm8//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAwEBPxAn/8QAFhEAAwAAAAAAAAAAAAAAAAAAEBEh/9oACAECAQE/EFB//8QAFxABAQEBAAAAAAAAAAAAAAAAAREAUf/aAAgBAQABPxBxdXMkZppGAWZ1b//Z","sizes":"(max-width: 1200px) 100vw, 1200px","src":"/static/1f9447eff0c9806d91cdbe43fb14f215/47498/progressive-loading-cover.jpg","srcSet":"/static/1f9447eff0c9806d91cdbe43fb14f215/2f037/progressive-loading-cover.jpg 930w,\n/static/1f9447eff0c9806d91cdbe43fb14f215/47498/progressive-loading-cover.jpg 1200w"}}},"author":{"id":"Anton","bio":"Anton Lavrenov","avatar":{"children":[{"fixed":{"src":"/static/d0b7acc08864a814c399f5bd88540f65/25252/anton.jpg"}}]}}},"fields":{"layout":"post","slug":"/progressive-loading-for-modern-web-applications-via-code-splitting-fb43999735c6/"}},"primaryTag":"react"}}}