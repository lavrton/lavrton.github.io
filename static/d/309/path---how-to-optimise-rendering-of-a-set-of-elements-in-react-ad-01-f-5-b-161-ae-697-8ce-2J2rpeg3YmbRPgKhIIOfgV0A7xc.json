{"data":{"logo":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABFUlEQVQY023PvUrDUBTA8ZuCtoMoOLQ4dWhN14x2kEKXFkGoohQ/QBexOHRycAidKkgHHRq69APRoTjFJYODIA6+gSBYfYMmfYLE/5VT6NALP845NyeHc9UoCHZRQvonCLKKE4ZhAXYURTsYoE9dIy5iCzfUJnEdV+RF4iu6ikFH2EPxazzOcJmg4Rnn5C8ysIEOHqTe5/sT3qXOwYOtRr5/wLAqzpCTDXu4p2ETtyjgGJ/cX+se8jeU9fa4RBt5vWENpjzdkoGPcGg4RQsbOMEFmnBRRwVDHEK/yFXfvr/CoPjvZLKcdByDyzWGeajigzorGy0oOeRJiUtITe/pX1XzDk3buIMltSFR/zTtic3060X+8z8PsEUt8G3LVQAAAABJRU5ErkJggg==","width":400,"height":128,"src":"/static/ghost-logo-2b5eaa0de166a8b5faebad4955c2200c-51380.png","srcSet":"/static/ghost-logo-2b5eaa0de166a8b5faebad4955c2200c-51380.png 1x"}}},"markdownRemark":{"html":"<h1>Tips to optimise rendering of a set of elements in React</h1>\n<p>There is a guide to increase React performance. The advanced tip will increase speed by 20 times.</p>\n<p>Rendering a list of some elements in a page is a common task for almost any web-app. In this post I would like to show how to improve performance for that case.</p>\n<p>For a test example we will create app that draws a set of targets (circles) on the <code>&#x3C;canvas></code> element. I will use Redux for a data storage. But these tips can be applied for many other state managing approaches. Also, you can use these tips with react-redux, but for a clear explanation I will not use it.</p>\n<p>Let me start from store definition.</p>\n<pre><code class=\"language-javascript\">function generateTargets() {\n    return _.times(1000, (i) => {\n        return {\n            id: i,\n            x: Math.random() * window.innerWidth,\n            y: Math.random() * window.innerHeight,\n            radius: 2 + Math.random() * 5,\n            color: Konva.Util.getRandomColor()\n        };\n    });\n}\n\n// for test case our logic will be very simple\n// just one action UPDATE for updating radius of a target\nfunction appReducer(state, action) {\n   if (action.type === 'UPDATE') {\n       const i = _.findIndex(state.targets, (t) => t.id === action.id);\n       const updatedTarget = {\n           ...state.targets[i],\n           radius: action.radius\n       };\n       state = {\n           targets: [\n               ...state.targets.slice(0, i),\n               updatedTarget,\n               ...state.targets.slice(i + 1)\n           ]\n       }\n   }\n   return state;\n}\n\nconst initialState = {\n    targets: generateTargets()\n};\n// create redux store\nconst store = Redux.createStore(appReducer, initialState);\n</code></pre>\n<p>Then define our application rendering. I will use <a href=\"https://konvajs.github.io/docs/react/\" target=\"_blank\">react-konva</a> for canvas rendering.</p>\n<pre><code class=\"language-javascript\">function Target(props) {\n    const {x, y, color, radius} = props.target;\n    return (\n        &#x3C;Group x={x} y={y}>\n            &#x3C;Circle\n                radius={radius}\n                fill={color}\n            />\n            &#x3C;Circle\n                radius={radius * 1 / 2}\n                fill=\"black\"\n            />\n            &#x3C;Circle\n                radius={radius * 1 / 4}\n                fill=\"white\"\n            />\n        &#x3C;/Group>\n    );\n}\n\n// top component with list of targets\nclass App extends React.Component {\n    constructor(...args) {\n        super(...args);\n        this.state = store.getState();\n        // subscibe to all state updates\n        store.subscribe(() => {\n            this.setState(store.getState());\n        });\n    }\n    render() {\n        const targets = this.state.targets.map((target) => {\n            return &#x3C;Target key={target.id} target={target}/>;\n        });\n        const width = window.innerWidth;\n        const height = window.innerHeight;\n        return (\n            &#x3C;Stage width={width} height={height}>\n                &#x3C;Layer hitGraphEnabled={false}>\n                    {targets}\n                &#x3C;/Layer>\n            &#x3C;/Stage>\n        );\n    }\n}\n</code></pre>\n<p><a href=\"https://codepen.io/lavrton/pen/GZXzGm/\" target=\"_blank\">Open demo</a></p>\n<p>Now let‚Äôs create a simple test script that will run several updates on one target:</p>\n<pre><code class=\"language-javascript\">const N_OF_RUNS = 500;\nconst start = performance.now();\n_.times(N_OF_RUNS, () => {\n    const id = 1;\n    let oldRadius = store.getState().targets[id].radius;\n    // update redux store\n    store.dispatch({type: 'UPDATE', id, radius: oldRadius + 0.5});\n});\nconst end = performance.now();\n\nconsole.log('sum time', end - start);\nconsole.log('average time', (end - start) / N_OF_RUNS);\n</code></pre>\n<p>Let‚Äôs run test script for the app without any optimisations. On my machine, an update will take ~21ms.</p>\n<p>This time doesn‚Äôt include canvas drawing, only redux + react code because <em>react-konva</em> is drawing objects only on the next animation frame tick. We are not interested in a canvas optimisation right now, it can be a subject of another post.</p>\n<p>So ~21ms for 1000 elements is pretty good performance. If we update elements rarely we can keep this code the way it is.</p>\n<p>But I had a case where I need to execute update very frequently (on every mouse move during drag&#x26;drop). For 60 FPS animation, each update should take no more than 16ms. So 21ms is not so good for this case (plus will have canvas drawing).</p>\n<p>How can we optimise rendering?</p>\n<h2>Don‚Äôt update unchanged elements</h2>\n<p>This is a first rule to improve React performance. All we need is to implement <code>shouldComponentUpdate</code> for Target Element:</p>\n<pre><code class=\"language-javascript\">class Target extends React.Component {\n    shouldComponentUpdate(newProps) {\n        return this.props.target !== newProps.target;\n    }\n    render() {\n        const {x, y, color, radius} = this.props.target;\n        return (\n            &#x3C;Group x={x} y={y}>\n                &#x3C;Circle\n                    radius={radius}\n                    fill={color}\n                />\n                &#x3C;Circle\n                    radius={radius * 1 / 2}\n                    fill=\"black\"\n                />\n                &#x3C;Circle\n                    radius={radius * 1 / 4}\n                    fill=\"white\"\n                />\n            &#x3C;/Group>\n        );\n    }\n}\n</code></pre>\n<p><a href=\"http://codepen.io/lavrton/pen/XdPGqj\" target=\"_blank\">Open demo</a></p>\n<p>Now it takes ~4ms vs 21ms. This is much better. But can we do more? In my real app even after this optimisation the performance was still bad.</p>\n<h2>Advanced tuning</h2>\n<p>Now take a look into <code>render()</code> function of App component. The thing I don‚Äôt like in this code is that <code>render()</code> of app component will be called on EACH update.</p>\n<p>That means we have more that 1000 calls for <strong>React.createElement</strong> for each target. In this case, it works fast but in larger apps it can be slow.</p>\n<p>Why should we rerender the whole list if we know that only particular components are updated? Can we just directly update them?</p>\n<h2>Make child components smarter</h2>\n<p>The idea is simple:</p>\n<ol>\n<li>Don‚Äôt update the app component if a list has the same number of elements and order of elements is the same</li>\n<li>Children components should update itself if data is changed</li>\n</ol>\n<p>So ‚ÄúTarget‚Äù component should subscribe to store and track changes:</p>\n<pre><code class=\"language-javascript\">class Target extends React.Component {\n    constructor(...args) {\n        super(...args);\n        this.state = {\n            target: store.getState().targets[this.props.index]\n        };\n        // subscibe to all state updates\n        this.unsubscribe = store.subscribe(() => {\n            const newTarget = store.getState().targets[this.props.index];\n            if (newTarget !== this.state.target) {\n                this.setState({\n                    target: newTarget\n                });\n            }\n        });\n    }\n    shouldComponentUpdate(newProps, newState) {\n         return this.state.target !== newState.target;\n    }\n    componentWillUnmount() {\n      this.unsubscribe();\n    }\n    render() {\n        const {x, y, color, radius} = this.state.target;\n        return (\n            &#x3C;Group x={x} y={y}>\n                &#x3C;Circle\n                    radius={radius}\n                    fill={color}\n                />\n                &#x3C;Circle\n                    radius={radius * 1 / 2}\n                    fill=\"black\"\n                />\n                &#x3C;Circle\n                    radius={radius * 1 / 4}\n                    fill=\"white\"\n                />\n            &#x3C;/Group>\n        );\n    }\n}\n</code></pre>\n<p>And implement <code>shouldComponentUpdate</code> for App component:</p>\n<p>Result after that changes - <a href=\"http://codepen.io/lavrton/pen/bpxZjy\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://codepen.io/lavrton/pen/bpxZjy</a></p>\n<p>0.25ms for an update is much better now.</p>\n<h2>Bonus tip</h2>\n<p>Use <a href=\"https://github.com/mobxjs/mobx\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://github.com/mobxjs/mobx</a> to skip all of this subscribing code. Same app using mobx (<a href=\"http://codepen.io/lavrton/pen/WwPaeV\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://codepen.io/lavrton/pen/WwPaeV</a>) - 0.16ms. About 1.5x faster than the previous result (and difference will be much more if you have more elements). And code is much simpler:</p>\n<pre><code class=\"language-javascript\">const {Stage, Layer, Circle, Group} = ReactKonva;\nconst {observable, computed} = mobx;\nconst {observer} = mobxReact;\n\nclass TargetModel {\n    id = Math.random();\n    @observable x = 0;\n    @observable y = 0;\n    @observable radius = 0;\n    @observable color = null;\n    constructor(attrs) {\n        _.assign(this, attrs);\n    }\n}\n\nclass State {\n    @observable targets = [];\n}\n\n\nfunction generateTargets() {\n     _.times(1000, (i) => {\n        state.targets.push(new TargetModel({\n            id: i,\n            x: Math.random() * window.innerWidth,\n            y: Math.random() * window.innerHeight,\n            radius: 2 + Math.random() * 5,\n            color: Konva.Util.getRandomColor()\n        }));\n    });\n}\n\nconst state = new State();\ngenerateTargets();\n\n\n@observer\nclass Target extends React.Component {\n    render() {\n        const {x, y, color, radius} = this.props.target;\n        return (\n            &#x3C;Group x={x} y={y}>\n                &#x3C;Circle\n                    radius={radius}\n                    fill={color}\n                />\n                &#x3C;Circle\n                    radius={radius * 1 / 2}\n                    fill=\"black\"\n                />\n                &#x3C;Circle\n                    radius={radius * 1 / 4}\n                    fill=\"white\"\n                />\n            &#x3C;/Group>\n        );\n    }\n}\n\n@observer\nclass App extends React.Component {\n    render() {\n        const targets = state.targets.map((target) => {\n            return &#x3C;Target key={target.id} target={target}/>;\n        });\n        const width = window.innerWidth;\n        const height = window.innerHeight;\n        return (\n            &#x3C;Stage width={width} height={height}>\n                &#x3C;Layer hitGraphEnabled={false}>\n                    {targets}\n                &#x3C;/Layer>\n            &#x3C;/Stage>\n        );\n    }\n}\n\nReactDOM.render(\n  &#x3C;App/>,\n  document.getElementById('container')\n);\n\n\n// update one target\nstate.targets[1].radius += 0.5\n</code></pre>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"Tips to optimise rendering of a set of elements in React"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"There is a guide to increase React performance. The advanced tip will increase speed by 20 times."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Rendering a list of some elements in a page is a common task for almost any web-app. In this post I would like to show how to improve performance for that case."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For a test example we will create app that draws a set of targets (circles) on the "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"<canvas>"}]},{"type":"text","value":" element. I will use Redux for a data storage. But these tips can be applied for many other state managing approaches. Also, you can use these tips with react-redux, but for a clear explanation I will not use it."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let me start from store definition."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-javascript"]},"children":[{"type":"text","value":"function generateTargets() {\n    return _.times(1000, (i) => {\n        return {\n            id: i,\n            x: Math.random() * window.innerWidth,\n            y: Math.random() * window.innerHeight,\n            radius: 2 + Math.random() * 5,\n            color: Konva.Util.getRandomColor()\n        };\n    });\n}\n\n// for test case our logic will be very simple\n// just one action UPDATE for updating radius of a target\nfunction appReducer(state, action) {\n   if (action.type === 'UPDATE') {\n       const i = _.findIndex(state.targets, (t) => t.id === action.id);\n       const updatedTarget = {\n           ...state.targets[i],\n           radius: action.radius\n       };\n       state = {\n           targets: [\n               ...state.targets.slice(0, i),\n               updatedTarget,\n               ...state.targets.slice(i + 1)\n           ]\n       }\n   }\n   return state;\n}\n\nconst initialState = {\n    targets: generateTargets()\n};\n// create redux store\nconst store = Redux.createStore(appReducer, initialState);\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Then define our application rendering. I will use "},{"type":"element","tagName":"a","properties":{"href":"https://konvajs.github.io/docs/react/","target":"_blank"},"children":[{"type":"text","value":"react-konva"}]},{"type":"text","value":" for canvas rendering."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-javascript"]},"children":[{"type":"text","value":"function Target(props) {\n    const {x, y, color, radius} = props.target;\n    return (\n        <Group x={x} y={y}>\n            <Circle\n                radius={radius}\n                fill={color}\n            />\n            <Circle\n                radius={radius * 1 / 2}\n                fill=\"black\"\n            />\n            <Circle\n                radius={radius * 1 / 4}\n                fill=\"white\"\n            />\n        </Group>\n    );\n}\n\n// top component with list of targets\nclass App extends React.Component {\n    constructor(...args) {\n        super(...args);\n        this.state = store.getState();\n        // subscibe to all state updates\n        store.subscribe(() => {\n            this.setState(store.getState());\n        });\n    }\n    render() {\n        const targets = this.state.targets.map((target) => {\n            return <Target key={target.id} target={target}/>;\n        });\n        const width = window.innerWidth;\n        const height = window.innerHeight;\n        return (\n            <Stage width={width} height={height}>\n                <Layer hitGraphEnabled={false}>\n                    {targets}\n                </Layer>\n            </Stage>\n        );\n    }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codepen.io/lavrton/pen/GZXzGm/","target":"_blank"},"children":[{"type":"text","value":"Open demo"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Now let‚Äôs create a simple test script that will run several updates on one target:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-javascript"]},"children":[{"type":"text","value":"const N_OF_RUNS = 500;\nconst start = performance.now();\n_.times(N_OF_RUNS, () => {\n    const id = 1;\n    let oldRadius = store.getState().targets[id].radius;\n    // update redux store\n    store.dispatch({type: 'UPDATE', id, radius: oldRadius + 0.5});\n});\nconst end = performance.now();\n\nconsole.log('sum time', end - start);\nconsole.log('average time', (end - start) / N_OF_RUNS);\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let‚Äôs run test script for the app without any optimisations. On my machine, an update will take ~21ms."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This time doesn‚Äôt include canvas drawing, only redux + react code because "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"react-konva"}]},{"type":"text","value":" is drawing objects only on the next animation frame tick. We are not interested in a canvas optimisation right now, it can be a subject of another post."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So ~21ms for 1000 elements is pretty good performance. If we update elements rarely we can keep this code the way it is."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"But I had a case where I need to execute update very frequently (on every mouse move during drag&drop). For 60 FPS animation, each update should take no more than 16ms. So 21ms is not so good for this case (plus will have canvas drawing)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"How can we optimise rendering?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Don‚Äôt update unchanged elements"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This is a first rule to improve React performance. All we need is to implement "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"shouldComponentUpdate"}]},{"type":"text","value":" for Target Element:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-javascript"]},"children":[{"type":"text","value":"class Target extends React.Component {\n    shouldComponentUpdate(newProps) {\n        return this.props.target !== newProps.target;\n    }\n    render() {\n        const {x, y, color, radius} = this.props.target;\n        return (\n            <Group x={x} y={y}>\n                <Circle\n                    radius={radius}\n                    fill={color}\n                />\n                <Circle\n                    radius={radius * 1 / 2}\n                    fill=\"black\"\n                />\n                <Circle\n                    radius={radius * 1 / 4}\n                    fill=\"white\"\n                />\n            </Group>\n        );\n    }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://codepen.io/lavrton/pen/XdPGqj","target":"_blank"},"children":[{"type":"text","value":"Open demo"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Now it takes ~4ms vs 21ms. This is much better. But can we do more? In my real app even after this optimisation the performance was still bad."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Advanced tuning"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Now take a look into "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"render()"}]},{"type":"text","value":" function of App component. The thing I don‚Äôt like in this code is that "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"render()"}]},{"type":"text","value":" of app component will be called on EACH update."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"That means we have more that 1000 calls for "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"React.createElement"}]},{"type":"text","value":" for each target. In this case, it works fast but in larger apps it can be slow."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Why should we rerender the whole list if we know that only particular components are updated? Can we just directly update them?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Make child components smarter"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The idea is simple:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Don‚Äôt update the app component if a list has the same number of elements and order of elements is the same"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Children components should update itself if data is changed"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So ‚ÄúTarget‚Äù component should subscribe to store and track changes:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-javascript"]},"children":[{"type":"text","value":"class Target extends React.Component {\n    constructor(...args) {\n        super(...args);\n        this.state = {\n            target: store.getState().targets[this.props.index]\n        };\n        // subscibe to all state updates\n        this.unsubscribe = store.subscribe(() => {\n            const newTarget = store.getState().targets[this.props.index];\n            if (newTarget !== this.state.target) {\n                this.setState({\n                    target: newTarget\n                });\n            }\n        });\n    }\n    shouldComponentUpdate(newProps, newState) {\n         return this.state.target !== newState.target;\n    }\n    componentWillUnmount() {\n      this.unsubscribe();\n    }\n    render() {\n        const {x, y, color, radius} = this.state.target;\n        return (\n            <Group x={x} y={y}>\n                <Circle\n                    radius={radius}\n                    fill={color}\n                />\n                <Circle\n                    radius={radius * 1 / 2}\n                    fill=\"black\"\n                />\n                <Circle\n                    radius={radius * 1 / 4}\n                    fill=\"white\"\n                />\n            </Group>\n        );\n    }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"And implement "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"shouldComponentUpdate"}]},{"type":"text","value":" for App component:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Result after that changes - "},{"type":"element","tagName":"a","properties":{"href":"http://codepen.io/lavrton/pen/bpxZjy","target":"_blank","rel":["nofollow","noopener","noreferrer"]},"children":[{"type":"text","value":"http://codepen.io/lavrton/pen/bpxZjy"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"0.25ms for an update is much better now."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Bonus tip"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Use "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/mobxjs/mobx","target":"_blank","rel":["nofollow","noopener","noreferrer"]},"children":[{"type":"text","value":"https://github.com/mobxjs/mobx"}]},{"type":"text","value":" to skip all of this subscribing code. Same app using mobx ("},{"type":"element","tagName":"a","properties":{"href":"http://codepen.io/lavrton/pen/WwPaeV","target":"_blank","rel":["nofollow","noopener","noreferrer"]},"children":[{"type":"text","value":"http://codepen.io/lavrton/pen/WwPaeV"}]},{"type":"text","value":") - 0.16ms. About 1.5x faster than the previous result (and difference will be much more if you have more elements). And code is much simpler:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-javascript"]},"children":[{"type":"text","value":"const {Stage, Layer, Circle, Group} = ReactKonva;\nconst {observable, computed} = mobx;\nconst {observer} = mobxReact;\n\nclass TargetModel {\n    id = Math.random();\n    @observable x = 0;\n    @observable y = 0;\n    @observable radius = 0;\n    @observable color = null;\n    constructor(attrs) {\n        _.assign(this, attrs);\n    }\n}\n\nclass State {\n    @observable targets = [];\n}\n\n\nfunction generateTargets() {\n     _.times(1000, (i) => {\n        state.targets.push(new TargetModel({\n            id: i,\n            x: Math.random() * window.innerWidth,\n            y: Math.random() * window.innerHeight,\n            radius: 2 + Math.random() * 5,\n            color: Konva.Util.getRandomColor()\n        }));\n    });\n}\n\nconst state = new State();\ngenerateTargets();\n\n\n@observer\nclass Target extends React.Component {\n    render() {\n        const {x, y, color, radius} = this.props.target;\n        return (\n            <Group x={x} y={y}>\n                <Circle\n                    radius={radius}\n                    fill={color}\n                />\n                <Circle\n                    radius={radius * 1 / 2}\n                    fill=\"black\"\n                />\n                <Circle\n                    radius={radius * 1 / 4}\n                    fill=\"white\"\n                />\n            </Group>\n        );\n    }\n}\n\n@observer\nclass App extends React.Component {\n    render() {\n        const targets = state.targets.map((target) => {\n            return <Target key={target.id} target={target}/>;\n        });\n        const width = window.innerWidth;\n        const height = window.innerHeight;\n        return (\n            <Stage width={width} height={height}>\n                <Layer hitGraphEnabled={false}>\n                    {targets}\n                </Layer>\n            </Stage>\n        );\n    }\n}\n\nReactDOM.render(\n  <App/>,\n  document.getElementById('container')\n);\n\n\n// update one target\nstate.targets[1].radius += 0.5\n"}]}]}],"data":{"quirksMode":false}},"excerpt":"Tips to optimise rendering of a set of elements in React There is a guide to increase React performance. The advanced tip will increase‚Ä¶","timeToRead":5,"frontmatter":{"title":"Tips to optimise rendering of a set of elements in React","userDate":"11 May 2016","date":"2016-05-11","tags":["react","performance"],"image":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAADc0lEQVQ4yz2TaU+bVxBG35/WH9BIldoPaZqQsoODbbyweAUveDfGGGxqNoNZo0AIuE0DIVCkEMBAA7SAkpS0RAgH7OCQEgSmnF6o1CuNNB/uPfeZmWckc40cr8NEo9eK11WPrlqJrLSAssJ8SvO/Q1l+G3nJVyjK72C3GLHVGQn63TitRup0KnQaGVpFAaqKfBRleUgaWTG6yjIc9bU0NTpp9Dsx6LQCWkTx93cpL8yjVn2LKlUh1nqT+LSBUJOPBouBWq2MalUxNepSNMoiKisKkRzeCBarC0OtDkONFotZj8vZQIPdTpVGi0ImR6eV43YqMRqM+Dw+PA4nJl2leKPApFdjFEqvcn11BdLQwxGGxiaIP3hER3yYQHMEh8ODxxOgNdxBpK0Tr9dPg60Ko74MtVIl1KpF6XrcLhtOhwWH3YTNUkudSYs0kRgh8XiMqZmnPF9aYW1zh99f7bK6tsnCYpKVl2usri8T641xr6yIb7+5gVx2j5ZQC62tIZpDAfx+F263TVRlRvr5yQTPZqdZSq7y29YOb3cPyGQ/kbvIkcvlOMpmSWfSvNn5g4HhhFAUEb300NMbpzsWIyaiq7tLVNJKsDmANPn0MYvJJH/t7pM5OuHgMMt+KsX+fopM5oiTk89cXPzD6zc7xDp7KL1bSLW6hpHRcQYGh+nrH6C3r4+4iP7BIaTkyhLrGxskl17ybGae5ZX1a+DZ+TlX5/Lykr29Xeamxxntj1B06yZ1Ynj9fYPcfzDK4NB9enp6+CHaRjjSgtQcbBJSo4wnZoXKlADw/7nK0+n3LCfn+XVxirXlWczCp9XyQsIBH9G2dgEcvi67rS1CqCWI1BkfZ/PVPue5/yDn5xcictewjOjd5uYav0yLgc08YmvjBU3C/AZNOTrhu6DXRaOwUXt7VDgiRCDgR9p+/SfZ7EdOT884Pj7l5O8zLgQ4lUqzMD/H4ovnTIw8ZHSwW6icFMqER81alCV5GFRF+J126vR6/D43/oAHKZP+wNGHY969OyD1/iOfBW13L81PiSmGBwaYfjJHRyhMm7icGOmlo7URbUUJhiold77+En1lPi6rCY28QiyFAenw8Ij1tW22t96SFgo/CeDU5ALRcCdd0S5+HJvGZ7XjMtcQjzbTGQ6iKBFrVl5MgRjQzRtfYDPIrne8JO82/wKfkvOM+YYXvQAAAABJRU5ErkJggg==","aspectRatio":1.5,"src":"/static/react-perf-cover-fc2112a7c2685ea5d18f32c0f6479cc7-2fdd9.png","srcSet":"/static/react-perf-cover-fc2112a7c2685ea5d18f32c0f6479cc7-70339.png 930w,\n/static/react-perf-cover-fc2112a7c2685ea5d18f32c0f6479cc7-2fdd9.png 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"author":{"id":"Ghost","bio":"The professional publishing platform","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsSAAALEgHS3X78AAABMUlEQVQ4y2MwsXf5T03MMGogGBvbOYNpUwdXOIbJwdgwNQQNhCk0snX6r2thC8Y6QGxg7QCWA/FBcrgMxepCkAZrV6//EYmpYBydkvHfMzjiv5mj2//whJT/Nm7ecEMJGgjykp6V/f+AqLj/O/Ye+L8diA8dO/m/pbv/v72n3/+tu/f9D45N/K9naYcSFESFoRXQlSCX2rh7g/kgr1u5epIWhiAMCi/3wLD/fVNn/u+fNgtMT5g+6//kmXOB/Jn/PYLCwWrINnDijDlAPBvKJ8NAZC+DIgCkGYRBbJAYSV5GjpTte/b/PwiMkLj0nP8xqVn/Dxw9AY6kwOh40iIFlmzCgUkmKjnjvx0wdu08fMFskJi1mxfxyQY9YetAEzJyQic5YaNnPeTgIDnrjZaHJGMACtTMXoVAJ6sAAAAASUVORK5CYII=","width":400,"height":400,"src":"/static/ghost-5f2c129e42248a92c87b13b4293950cf-fba88.png","srcSet":"/static/ghost-5f2c129e42248a92c87b13b4293950cf-fba88.png 1x"}}]}}}},"relatedPosts":{"totalCount":3,"edges":[{"node":{"id":"13f0073b-f074-5f0e-846d-9cb6932a3efc","timeToRead":2,"excerpt":"Progressive loading for modern web applications via code splitting Are your users tired of waiting when your app is loading and they close‚Ä¶","frontmatter":{"title":"Progressive loading for modern web applications via code splitting"},"fields":{"slug":"/progressive-loading-for-modern-web-applications-via-code-splitting-fb43999735c6/"}}},{"node":{"id":"9f93c31f-d13b-592d-82f0-e4232942a934","timeToRead":5,"excerpt":"How to use React with canvas element? We have React that helps us to work with massive mutable DOM in a nice immutable functional style‚Ä¶","frontmatter":{"title":"Using React With Canvas Element"},"fields":{"slug":"/using-react-with-html6-canvas-871d07d8d753/"}}},{"node":{"id":"e94d0e07-9eab-5c8c-aef6-145d021dbd55","timeToRead":5,"excerpt":"Tips to optimise rendering of a set of elements in React There is a guide to increase React performance. The advanced tip will increase‚Ä¶","frontmatter":{"title":"Tips to optimise rendering of a set of elements in React"},"fields":{"slug":"/how-to-optimise-rendering-of-a-set-of-elements-in-react-ad01f5b161ae/"}}}]}},"pageContext":{"slug":"/how-to-optimise-rendering-of-a-set-of-elements-in-react-ad01f5b161ae/","prev":{"excerpt":"üëã Welcome, it's great to have you here. We know that first impressions are important, so we've populated your new site with some initial‚Ä¶","timeToRead":1,"frontmatter":{"title":"Welcome to Ghost","tags":["Getting Started"],"date":"2018-05-06T23:46:37.121Z","image":{"childImageSharp":{"fluid":{"aspectRatio":1.5238095238095237,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAQFAv/EABQBAQAAAAAAAAAAAAAAAAAAAAL/2gAMAwEAAhADEAAAAXtwmQ3SaFf/xAAaEAEBAAIDAAAAAAAAAAAAAAABAAIEEyIx/9oACAEBAAEFAjaLnJ2G8sHo3//EABcRAAMBAAAAAAAAAAAAAAAAAAACESH/2gAIAQMBAT8BWUw//8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQIBAT8BZ//EABgQAAIDAAAAAAAAAAAAAAAAABAhAAER/9oACAEBAAY/AnUQ0//EABkQAQEBAQEBAAAAAAAAAAAAAAEAESFBUf/aAAgBAQABPyF7iksLlhsrjfuXy52fb//aAAwDAQACAAMAAAAQz/8A/8QAFhEBAQEAAAAAAAAAAAAAAAAAEQBx/9oACAEDAQE/EEBYv//EABgRAAMBAQAAAAAAAAAAAAAAAAABESFR/9oACAECAQE/ELStN6f/xAAaEAEAAwEBAQAAAAAAAAAAAAABABEhUTFB/9oACAEBAAE/ELMm/bwOvIgAjWaRSUEVBKKnfsuyNPIs/wD/2Q==","sizes":"(max-width: 1600px) 100vw, 1600px","src":"/static/welcome-to-ghost-137c53aaeb1d869ab1c3c94764b1d7fa-f51c1.jpg","srcSet":"/static/welcome-to-ghost-137c53aaeb1d869ab1c3c94764b1d7fa-890a7.jpg 930w,\n/static/welcome-to-ghost-137c53aaeb1d869ab1c3c94764b1d7fa-f51c1.jpg 1600w"}}},"author":{"id":"Ghost","bio":"The professional publishing platform","avatar":{"children":[{"fixed":{"src":"/static/ghost-5f2c129e42248a92c87b13b4293950cf-fba88.png"}}]}}},"fields":{"layout":"post","slug":"/welcome/"}},"next":null,"primaryTag":"react"}}